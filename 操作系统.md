# 操作系统常见问题汇总
  	进程与线程的区别和联系  
进程是系统资源分配的基本单位，线程是系统CPU调度的基本单位。进程间切换开销较大，线程间切换开销小。  
线程可以共享进程除了栈空间外的所有资源，线程独占的空间有：TCB，栈，寄存器。  

	一个进程可以创建多少线程，和什么有关  
一般32位机中，一个进程可用虚存为2G，默认下一个线程栈的大小为1M，所以最多创建不到2048个线程（因为除了线程栈，还有代码段，PCB，TCB，数据段）。  
与线程栈大小和虚拟内存大小有关。  

	一个程序从开始运行到结束的完整过程（四个过程）  
预处理（.i，头文件编译进来，宏替换），编译（.s，各种分析后汇编语言），汇编（.o），链接（模块间，动态 静态）  

	进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）  
进程间通信【IPC】：Inter-Process Communication
- Linux IPC：  
	- 管道（匿名PIPE，命名FIFO）  
PIPE: cat xxx.log | grep 123  
FIFO: 创建：mkfifo myPipe，写：echo "write msg to pipe" > myPipe，读：cat < myPipe  
	- 消息队列（message queue）  
进程A往消息队列写入msg，进程B往消息队列取msg，但由于mq由内核维护，数据拷贝开销较大，实际上一般自行在用户空间实现，基本不用。  
	- 共享内存（shared memory）/内存映射（memory map）  
先不谈SystemV的API，POSIX风格的 mmap 和 munmap 就是一对共享内存的好助手，不同进程可以通过调用相同的mmap函数来映射同一块物理内存区域，从而获取同一块共享内存。通过semphore来控制共享内存的安全读写。   
	- 信号（signal）  
常见信号量：SIGINT(ctrl+c)，SIGCHLD(fork出子进程,父进程关闭时)，SIGKILL(kill -9)，SIGTSTP(ctrl+z)，SIGPIPE(TCP的RST)
	- 信号量（semaphore）  
常用于共享内存的操作，引入PV源语，PV操作必须成对使用：  
P：调用时信号量 -1，如果信号量 <0 说明资源被占用，进程阻塞等待  
V：调用时信号量 +1，如果信号量 <=0 说明存在进程阻塞等待，可以唤醒进程运行  
信号量初始化为 1 时，为互斥信号量，只有唯一进程可以操作共享内存。  
信号量初始化为 0 时，为同步信号量，进程间一个做完换另一个。  
	- 套接字（socket）  
老朋友了，无论是本机进程间（AF_LOCAL）还是互联网内主机进程间（AF_INET），都可以用socket。  
本地字节流（TCP:SOCK_STREAM）和本地数据报（UDP:SOCK_DGRAM）socket 在 bind 的时候，不需要四元组(地址和端口)，而是绑定一个本地文件(fd)。  
> Linux 线程间通信：同个进程下的线程共享进程的资源，用互斥量（mutex），条件变量（condition），信号量（semaphore）等控制资源竞争。  

Windows IPC：管道，消息队列，共享内存，信号量，套接字。  
Windows线程间：互斥量（mutex），临界区（critical section），信号量（semaphore），事件（event）。  

	文件读写使用的系统调用
读：read，readv，recv，recvmsg。  
区别：readv加入了iovec，recv加入了flag，recvmsg则涵盖前面所有函数的特点，加入了msghdr和cmsghdr（辅助数据）。  
写：write，writev，send，sendmsg，特点同上。  

	怎么回收线程  
1、对线程调用pthread_join()函数，等待线程执行完毕自动回收。  
2、线程分离，对线程调用pthread_detach()函数，将线程执行状态改为分离态。  
3、以分离形式创建子线程。  

	守护进程、僵尸进程和孤儿进程
守护进程：父进程是init进程，没有控制终端，在后台运行的进程。  
僵尸进程：子进程结束，父进程还在运行但没有wait（）子进程，子进程就变成僵尸进程，不能释放内存，需要等到init进程接管子进程，或者设计SIGCHLD信号处理函数。  
孤儿进程：父进程退出，子进程还在运行，被init接管，然后让init来wait（）回收资源。  

	处理僵尸进程的两种经典方法
1、让父进程wait（）子进程，但父进程会阻塞。  
2、创建子进程和孙进程，终止子进程，让init接管孙进程，自动进行资源回收。  

	进程终止的几种方式
正常终止：①return返回；②exit库函数退出；③_exit系统调用退出（不回收缓冲区）；  
异常终止：④收到信号终止（SIGINT，SIGTERM，SIGKILL）⑤abort异常终止。  

	linux中异常（同步中断）和中断（异步中断）的区别
中断是异步的，一般由外部设备发出；异常是同步的，一般由CPU发出。  
一共有256种中断（0~255），0~31这32位系统保留使用，第128位（0x80）是系统中断的入口，剩余的可以定制。  

	一般情况下在Linux/windows平台下栈空间的大小  
可以用ulimit看见linux下栈空间默认为8192KB即8MB；Windows默认为1MB。  

	五种IO模型
阻塞I/O，非阻塞I/O，信号I/O，I/O复用，异步I/O。  

	守护进程  
7个步骤创建，  
①创建屏蔽字umask(0)。  
②fork一次，终止父进程，让shell以为命令执行完毕。  
③创建新会话setsid()，让当前进程成为新的进程首和会话首。  
④再fork一次，终止父进程，让控制终端无法自带生成。  
⑤更改当前目录为根目录。  
⑥关闭所有打开的文件描述字。  
⑦重定向标准输入，输出和标准错误输出。  

	程序从堆中动态分配内存时，虚拟内存上怎么操作的
程序员通过mallco/free申请和释放内存，<128K的内存使用brk分配，>128K使用mmap，这两种方式分配的都是虚拟内存，没有分配物理内存。  
在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。  
 
	交换空间与虚拟内存的关系
两者都是从磁盘划出一部分空间，来应对内存不足的情况；只不过swap是Linux使用的，虚拟内存是Windows使用的。  

	堆和栈的区别；从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）
堆的内存可以通过库函数或系统调用灵活分配，但速度较慢，且容易产生碎片；栈的内存由操作系统管理实现，有硬件支持（寄存器存储指令）速度较快。  

	内存泄漏和内存溢出
内存泄露指动态分配的内存没有完全回收；内存溢出指申请的内存大于系统剩余的内存，即内存不够用了。  

	常见内存分配方式和错误
方式：  
1、静态存储区：创建static变量。  
2、栈：局部变量。  
3、堆：动态内存分配。  
常见错误：  
1、内存申请失败，但仍然使用了；  
2、内存申请成功，但没有初始化；  
3、内存申请成功且初始化，但内存访问越界；  
4、内存使用完毕没有释放，导致内存泄露；  
5、使用了已经释放过的内存；  
6、重复释放已经释放过的内存。 

	堆内存和栈内存的区别（JAVA内容？）  
	
	可重入函数和可重入内核  
可重入函数：多线程中重复执行能够得到相同结果的，有复现性的，线程安全的，不递归调用自身的，不包含静态全局变量的函数。  
可重入内核：若干个进程可以同时在内核态下执行，也就是说多个进程可以在内核态下并发执行内核代码。  

	操作系统动态内存分配的几种策略  
①首部适应算法（first fit）：从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，从低地址到高地址。  
②最佳适应算法（best fit）：从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区的一种计算方法。  
③最差适应算法（worst fit）：扫描整个空闲分区或链表，总是挑选一个最大的空闲分区分割给作业使用。  
④循环首部适应算法（next fit）：不再每次从表头（链首）开始查找，而是从上次找到空闲区的下一个空闲开始查找（从上一次使用首次适应法查找的结果开始查找）。 

	内部碎片和外部碎片
内部碎片：申请一个10K大小内存，只剩下16K的内存块可以分配了，那么产生6K无法使用的碎片，就是内部碎片，指那些分配出去用不上的内存碎片。  
外部碎片：多次内存分配后，那些太小了无法被任何进程使用的内存碎片就是外部碎片。  

	系统调用进入内核态的过程
使用系统调用，CPU产生异常，外设产生中断都会导致用户态到内核态的切换。
用户调用系统调用（传参，如果有的话），产生一次异常（int 0x80），（这里开始是内核态）CPU在中断异常表中找到对应的异常类型，然后调用system_call()调用对应的函数（如write调用sys_write），最后在内核中将结果返回给用户态（ret_from_sys_call()）。  

	内核态和用户态的区别
内核态的运行级别是Ring0最高，用户态是Ring3最低。内核态可以执行特权指令，用户态不行。内核态可以访问内存所有数据，用户态只能访问部分内存，且不能访问外设。  

	常见的进程调度算法以及linux的进程调度
先来先服务（FCFS）：先进先出，排队服务，每个进程花一样的时间片，不够重排。  
短作业优先（SJF）：执行时间短的进程优先获得CPU，长作业可能发生饿死。  
优先级法：优先级高的先获得处理机，分为可抢占和不可抢占式，静态优先还是动态优先。  
时间片轮转法（RR）：进程轮流使用时间片，时间片用光进程就阻塞（被剥夺）。  
***  
前四个为主流，后四个为辅助。  
***  
最短剩余时间优先（SRTF）：SJF的变形，如果新来的进程运行时间比当前进程所需时间还短，就强行剥夺CPU的控制权。  
多级队列（MQ）：根据作业的特性，将不同作业放入不同队列，每个队列有自己的调度算法，各个队列间采用固定优先级的抢占式调度。  
高响应比优先法（HRRF）：为每个进程计算一个响应比："RR=1+"  W/S，w是进程等待处理机的时间，s是进程要求的服务时间，RR越大，优先级越高，是一种非抢占式的调度策略。  
多级反馈队列（MFQ）：设计多个队列，每个队列时间片长度不同，优先级高的时间片小，新进程先进入第一队列，时间片不足排到下一队列尾部，每个队列按照FCFS服务，一直到第N队列，按RR服务。  

	中断、陷阱、故障和终止  
中断：异步的，外部中断，中断处理程序返回到当前指令的下一条指令。  
陷阱：同步的，内部异常，CPU执行指令的结果，返回到当前指令（用户态内核态切换）。  
故障：同步的，内部异常，CPU执行指令出现了错误，跳转到对应的异常处理，如果成功修复错误，跳转回来继续执行指令；否则执行下面“终止”的情况。  
终止：内部异常，因为发生了无法处理的错误，跳到abort例程终止程序。（缺页中断）  

	进程通信方法
同步进程通信：管道（PIPE）、命名管道（FIFO）、消息队列、共享内存、信号量（semaphore）、套接字（socket）。  
异步进程通信：信号。  

	线程互斥和同步的方法
互斥：互斥量、读写锁、自旋锁。  
同步：轮询结合互斥量、条件变量、信号量、屏障。  

	内存对齐的规则和作用
结构体内数据块按照最大的数据类型进行划分，不够的补齐一块。  
内存对齐可以有效的加快CPU访存速度，且提高程序的可移植性，因为有的平台的CPU不支持内存不对齐的程序。  

	CPU调度算法（时间片怎么分）
先来先服务（FCFS First Come First Serve）：如其名  
短作业优先（SJF Short Job First）：根据作业时间长短排序  
高响应比优先（HRRN High-Response Ratio Next）：响应比优先级 = （等待时间+要求服务时间）/要求服务时间，因为进程要求服务时间是不确定的，算法不可实现  
时间片轮转（RR Round Robin）：每个进程分固定时间片，用完回到队尾排队  
最高优先级（HPF High-Priority First）：分是否抢占，静态优先级创建进程决定，动态优先级根据等待时间决定，越长越高  
多级反馈队列（MFQ Multilevel Feedback Queue）：进程在不同优先级队列排队，优先级高时间片短，反之，保证高优先级不要占用太多时间片，兼顾了长短作业  

	页面置换算法
最佳页面置换（OPT）：预测未来最久不使用页面，将其替换，实际不可实现。  
最近最久未使用（LRU）：看当前内存内页面哪个使用频率最低，就把它替换出去。  
最近未使用（NRU）：为每个页面设置两个位，一个是被访问R（read）位，另一个是被修改M（modify）位，每个时钟中断都清空R位，根据RM：00、01、10、11分为四种，替换最小的那个页面。  
先进先出（FIFO）：替换最先进来的页面，和队列一样。  
第二次机会算法：FIFO的变体，链表实现。给每个页面加入一个R位，替换最老页面时，如果R位=0（表示最近没有使用）就把它替换，如果R位=1（表示最近还有使用）就把他放到链表最后，并把R位置0，继续往后寻找第二老的页面，直到找到。  
时钟算法：类似上面，只是变成环形链表。R=0替换指针所指页面，R=1就R置0，然后指针前移一位，直到找到R=0的页面将它替换。  

	实现一个LRU页置换算法（或者FIFO置换算法）  
	
	死锁的必要条件（怎么检测死锁，解决死锁问题）,银行家算法（死锁避免）  
4个条件：互斥，不可剥夺(抢占)，占有且申请，环路(循环)等待。  
检测：单体资源类：等待图，图中有环路就有死锁。  
多体资源类：类似银行家算法的数据结构，  
Work = Available：系统可用各种资源的数组。  
Allocation_i：i进程获得了各种资源的数组，下面简称为AI数组。  
Request_i：i进程还需要各种资源的数组，下面简称为RI数组。  
Finish：布尔型数组，记录i进程是否能够获得足够各种资源。  
步骤如下：① 如果AI≠0，Finish[i]=false；否则为true。    
② 寻找（Finish[i]==false && RI<=Work）如果不存在这样的i，跳到④。    
③ 如果找到，修改Work += AI，跳回②，继续找下一个i。（模拟进程完成，归还了资源）  
④ 找不到这样的i说明有的进程资源永远得不到满足，系统处于死锁状态。  
解决：①剥夺别的进程资源、②杀死死锁的进程、③进程回退到安全点。  
避免：银行家算法，按顺序给进程分配不同类型的资源。  

	乐观锁悲观锁
悲观：认为共享资源被同时访问修改的概率高，所以在操作前都会申请锁。互斥锁、自旋锁、读写锁，都是属于悲观锁  
乐观：认为修改概率较低，在修改完再验证是否有它人修改过，如果有就放弃本次操作。如 SVN 通过版本号检测冲突，和各种在线文档  

	哲学家就餐，读者写者，生产者消费者（怎么加锁解锁，伪代码，PV操作）
读者写者：读者优先，三个变量rmutex，wmutex，rcount，有人读的时候，就无法写，且增加rcount，只有当rcount==0的时候才释放wmutex，让写者可以进行写操作。  
哲学家就餐：5个人一圆桌，一共5根筷子，每个人左右各1根。左右没吃，自己就在吃。  
生产者消费者：三个变量full=0，empty=N，mutex=1。生产者P(empty)，V(full)；消费者P(full)，V(empty)，两者操作buffer时P(mutex)，用完V(mutex)。  
```cc
#define BUFF_SIZE 123
typedef semaphore sem
sem mutex = 1;
sem empty_buf = BUFF_SIZE;
sem full_buf = 0;

void producer()
{
	while(1)
	{
		P(empty_buf);
		P(mutex);
		//add data to buffer
		V(mutex);
		V(full_buf);
	}
}

void consumer()
{
	while(1)
	{
		P(full_buf);
		P(mutex);
		//get data from buffer
		V(mutex);
		V(empty_buf);
	}
}
```
