# Skynet框架
> 工作中服务器模型是类似这个开源框架的，是一个单进程多线程的服务器模型，基于C和lua。学习这个模型对项目的框架也能更好的理解。
## 前网易现ejoy大佬云风写的基于ACTOR模型的Skynet框架
> [云风的blog-skynet](https://blog.codingnow.com/2012/09/the_design_of_skynet.html)

## Actor模型好处
1. 事件模型驱动： Actor之间的通信是异步的，即使Actor在发送消息后也无需阻塞或者等待就能够处理其他事情。  
2. 强隔离性： Actor中的方法不能由外部直接调用，所有的一切都通过消息传递进行的，从而避免了Actor之间的数据共享，想要观察到另一个Actor的状态变化只能通过消息传递进行询问。  
3. 位置透明： 无论Actor地址是在本地还是在远程机上对于代码来说都是一样的。  
4. 轻量性：Actor是非常轻量的计算单机，只需少量内存就能达到高并发。  
> 作者：简单说，Skynet 只负责把一个数据包从一个服务内发送出去，让同一进程内的另一个服务收到，调用对应的 callback 函数处理。它保证，模块的初始化过程，每个独立的 callback 调用，都是相互线程安全的。编写服务的人不需要特别的为多线程环境考虑任何问题。专心处理发送给它的一个个数据包。

## 服务
preload会预加载服务对应的函数，环境变量也被加载进去，且只增不减。  
环境变量设置完成后，当前节点上所有服务都可以访问到，即使服务退出了，所以要慎用。  
服务分为普通服务和全局唯一服务。  

### 分类
普通服务通过：*newservice(servicename)* 创建  

唯一服务通过：*uniqueservice(true,servicename)* 创建，如果带了true参数表示服务在所有节点唯一，否则在本节点唯一  

查询服务使用：*queryservice(true,servicename)* true含义同上   

### 别名
别名：本地别名以'.'开头，如.alias，全局别名不能以点开头，通过:*name("(.)alias",servicename)设置  

注意杀死别名服务后，本地别名变为nil，但全局的别名依然存在，使用它会导致不可预知的错误。  
还有，注意区分全局唯一服务名和全局别名。
### 调度
> 因为这一块底层封装了，所以快速浏览一遍，暂不深究  

Name | Description
:-:|-
skynet.sleep(time) | 让当前的任务等待 time * 0.01s。
skynet.fork(func, ...) | 虽然你也可以使用原生的coroutine.create来创建协程，但是会打乱skynet的工作流程;启动一个新的任务去执行函数 func , 其实就是开了一个协程，函数调用完成将返回线程句柄。
skynet.yield() | 让出当前的任务执行流程，使本服务内其它任务有机会执行，随后会继续运行。
skynet.wait() | 让出当前的任务执行流程，直到用 wakeup 唤醒它。
skynet.wakeup(co) | 唤醒用 wait 或 sleep 处于等待状态的任务。
skynet.timeout(time, func) | 设定一个定时触发函数 func ，在 time * 0.01s 后触发。
skynet.starttime() | 返回当前进程的启动 UTC 时间（秒）。
skynet.now()| 返回当前进程启动后经过的时间 (0.01 秒) 。
skynet.time() | 通过 starttime 和 now 计算出当前 UTC 时间（秒）。

### 服务间消息通信
> 项目使用的是REST API是restful风格的消息传递，rfc和传统RPC有一定区别。  
所谓 RPC 调用，就是一个远程对象加一个方法名，加上若干参数。通过序列化方法，打包成一个数据包，查询到远程对象所在的服务地址，发送过去即可。  
  
每种类型的服务，都在start处用dispatch进行绑定（注册），而参数的传递，由pack()打包；unpack()；解包trash()释放。

#### 消息处理
    1.不需响应的消息
send(addr, type, ...) --发送未打包的消息，函数自动打包...参数列表
rawsend(addr, tpye, msg, sz) --发送打包好的消息
redirect(dst, src, type, session, msg, sz) --伪造其它服务地址发送信息，可以用于白盒测试？

    2.必须响应的消息
call(addr, type, ...) --发送未打包的消息并等待响应，函数自动打包...参数列表并解包  
rawcall(addr, tpye, msg, sz) --发送打包好的消息，需要自行解包
session --保证本服务中发出的消息是唯一的

    3.响应消息
ret --用于返回服务处理消息的结果
retpack(...) --将消息用pack打包后再调用ret
response --不想接受请求和响应请求再同一个协程中完成时，用它代替ret

#### 消息队列
> 如果某个服务中有阻塞API，它挂起后仍能处理别的消息，可能得到未预计的结果，解决方法就是消息队列。  
> *本质上它就是个存放服务的临界区，项目中一般cs就是指消息队列。*

skynet维护了两级消息队列，全局消息队列里面放了所有不为空的次级消息队列。  
通过将消息先存入消息队列，再从消息队列中严格按照先后次序取出执行对应服务，保证了伪线程安全（可重入）。

#### 代理服务
所谓代理，就是讲请求的消息先发给代理服务，再由代理服务转发给真正处理这个请求的服务；  
同样的，处理的结果也是先返回给代理服务，再返回给请求。项目中一般用*proxy*表示代理。  
forward_type和start类似，前者还需要一张消息映射转换表，其它方法和start一样[skynet.PTYPE_OLDNAME]= skynet.PTYPE_NEWNAME

### 集群
虽然说skynet是单进程的，但是也可以建立集群。  
单进程的优点是数据都在内存中，通过传递C结构体指针，不同服务可以快速访问相同内存块的内容而无需建立TCP连接而产生额外的开销。甚至实现零拷贝，但这有风险。  
如果使用上了集群，不同的skynet节点就要使用服务来进行进程间通信了；  
在skynet中这个服务名叫harbor，它通过在两个/多个节点之间建立TCP连接完成数据交换的工作；  
还有一个master服务广播告知集群内所有节点新加入的节点地址。  

### 节点间消息通信
前面讲了单进程内的服务通信，不同skynet进程间也可以通信，方法有组播和广播。
